(ns expressions.default-build
  (:require
   [clojure.data.json :as json]
   [clojure.string :as str]
   expressions.ninja
   [expressions.transform-sorter :refer [trans-sorter]]
   [flower.fs :as fs]
   [flower.reflect :as reflect]
   flower.unsafe.fs)
  (:use expressions.utils))

; public helpers

(defn replace-ext [path ext]
  (-> path fs/path fs/strip-ext (str "." ext)))
(defn add-ext [path ext]
  (-> path fs/path (str "." ext)))
(defn prepend-ext [path new-ext]
  (let [[base old-ext] (-> path fs/path fs/split-ext)]
    (str/join "." [base new-ext old-ext])))

; private helpers
; NOTE for people who aren't jyn: it's fine to modify these to make them public.
; they just have no kind of back-compat guarantee, and i may change or break them
; in future releases of flower.

(defn- / [x & more]
  (apply fs/path x more))

(defn- all-dirs [root]
  (let [dirs (atom (if (fs/exists? root) #{root} #{}))
        update #(swap! dirs conj %)
        visitor (fn [path _attrs] (update path) :continue)]
    (flower.unsafe.fs/walk-file-tree root {:pre-visit-dir visitor})
    (map str @dirs)))

(def ^:private flower-cli (reflect/current-exe))
(def ^:private ff [flower-cli])

; TODO: don't hard-code these
(def ^:private public "public")
(def ^:private builddir ".build")

; NOTE: only looks at top-level transformers
(def ^:private transformers (fs/glob "transformers" "*"))
(def ^:private all-pages (remove fs/directory? (fs/glob "pages" "**")))
(def ^:private joined-frontmatter (/ builddir "all-frontmatter.json"))

(def ^:private sass-files
  ; excludes /_*.sass
  (filter #(-> % fs/file-name first (= \_) not)
          (fs/glob "sass" "**.{scss,sass}")))

(defn- sass->build [path]
  (let [relative-path (remove-parent path)
        out (/ public (replace-ext relative-path "css"))
        source-map (add-ext out "map")
        depfile (/ builddir (add-ext relative-path "d"))]
    {:rule "sass"
    ; needed because we pass this as a literal path to `sass`
    :inputs (if (fs/exists? path {:no-vfs true}) path
              (str (get reflect/all-defaults path path)))
    :outputs out
    :source-map source-map
    :depfile depfile}))

(def ^:private sass-builds {:builds (map sass->build sass-files)})
(def ^:private sass-outputs (map :outputs (:builds sass-builds)))

(defn frontmatter-path [page]
  (/ builddir (add-ext (remove-parent page) "json")))

(def all-frontmatter
  {:rules [{:name "join-frontmatter"
            :command (fmt "${flower-cli} join-frontmatter $out $in")
            :restat true
            :description "join all page frontmatter into a cache"}]
   :builds [{:rule "join-frontmatter"
             :inputs (map frontmatter-path all-pages)
             :outputs joined-frontmatter
             :implicit ff}]})

(defn- build-page
  ([page]
     {:rule "frontmatter"
      :inputs page
      :outputs (frontmatter-path page)
      :implicit ff}))

(defn- page-frontmatter [page]
  (-> reflect/*metadata* :pages (get (str page))))

; NOTE: we look at frontmatter contents here, but we only register a dependency on `all-frontmatter.json` so that we don't have to rebuild when only the file contents changes.
(defn- transform-page [page implicits]
  (let [meta-path (frontmatter-path page)
        depfile (add-ext meta-path "d")
        tmpfile (prepend-ext meta-path "transformed")
        final (->> page page-frontmatter :flower/path (/ public))]
    ; NOTE: if you have a custom build command you have to add a :build yourself
    {:rule "transform"
     :page page
     :inputs meta-path
     :outputs final
     :implicit (concat transformers implicits [joined-frontmatter])
     :tmpfile (escape-shell tmpfile)
     :depfile depfile}))

; TODO: this only works for post-processed pages; maybe we can late bind this or something? or expose it as a function?
; TODO: document that custom commands cannot generate the same output file as a page
; NOTE: if we want a default index.html, we cannot allow index.html to be generated by a custom command.
; document that you should use `include` if you want that.
(def ^:private page-builds
  (let [split-pages (map build-page all-pages)
        transformed (map #(transform-page % sass-outputs) all-pages)]
    {:builds (concat split-pages transformed)}))

(defn- static->build [path]
  {:rule (if (fs/directory? path) "mkdir" "link")
   :inputs (str (get reflect/all-defaults path path))
   :outputs (/ public (remove-parent path))})
(def static-builds {:builds (map static->build (fs/glob "static" "**" {:follow-links true}))})

(defn- settings []
  (str/join " "
    (map escape-shell
      (flatten
        (for [[k v] (:settings flower.reflect/*metadata*)]
          ["--set" (str k "=" v)])))))

(def ^:private redirects
  {:builds
   (for [[src dst] (:redirects flower.reflect/*metadata*)
         :let [srcp (strip-prefix src "/")]]
     {:rule "redirect"
      :outputs (/ public srcp)
      :depfile (/ builddir (add-ext srcp "d"))
      :target (escape-shell dst)})
   :rules
   [{:name "redirect"
     :command (fmt "echo $target | ${flower-cli} transform --standalone --raw-input --raw-output --depfile $depfile --out-file $out transformers/standalone/generate_redirect.clj >  $out")}]})

(def ^:private base
  ; NOTE: we can't put lists here, ninja interprets them as literal strings
  ; https://codeberg.org/jyn514/flower/issues/16
  {:variables {:builddir builddir}
   :phony (for [[virtual real] reflect/all-defaults]
           {:name virtual, :depends real})
   :rules
   [{:name "ninja-meta"
     :restat true
     :command (fmt "${flower-cli} configure $settings")
     :description "rebuild build.ninja itself"}
    {:name "mkdir"
     :command (str "mkdir -p " builddir)
     :description "create build dir"}
    {:name "link"
     :command "ln -f $in $out"
     :description "link $in into build dir"}
    {:name "frontmatter"
     :command (fmt "${flower-cli} split-frontmatter --filename $in < $in > $out")}
    {:name "sass"
     :command (fmt "sass --quiet $in $out; ${flower-cli} transform transformers/standalone/split_sass_dependencies.clj --standalone --raw-output --source-file=$out <$source-map >$depfile")
     :description "compile Sass file $in to CSS"}]
   :builds
   [{:rule "ninja-meta"
     :generator true
     :outputs "build.ninja"
     ; TODO: maybe we need to nest pages in builddir so they don't conflict?
     :depfile (/ builddir "build.clj.d")
     :inputs (concat ["flower.edn" "build.clj" joined-frontmatter] ff
                     ; NOTE: normally this would need to include pages/, but we already depend on all-frontmatter and vim likes to create temporary files
                     ; TODO: remove this once `fs/glob` tracks reads
                     (mapcat all-dirs ["sass"]))
     :settings (settings)}
    {:rule "mkdir"
     :outputs builddir}]})

(def ^:private transform
        ; TODO: shell escaping
  (let [files (->> transformers (sort trans-sorter) (map str) (str/join " "))
        ; well this kinda sucks. $in is quoted but $depfile is not, so we can't use it.
        ; instead we assume it's always relative to $in.
        cmd (str flower-cli " transform < $in --depfile $in.d --out-file $out "
                 "--transform-map $transform-map --all-frontmatter $all-frontmatter "
                 "--raw-output $transformers > $out")]
    {:variables {:transformers files
                 :transform-map (-> {} json/write-str escape-shell)
                 :all-frontmatter joined-frontmatter}
     :rules [{:name "transform"
              :command cmd
              :description "run all transformers on $page"}]}))

; public API

(defn default-build-plan
  "Generate the default build plan for a flower site.
   Modify this as you like, then pass it to `expressions.ninja/generate!`."
   [] (merge-deep page-builds transform static-builds sass-builds
                  redirects all-frontmatter base))
